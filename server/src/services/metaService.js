const axios = require('axios');
const openaiService = require('./openaiService');

// Configuration de l'API Meta
const META_API_VERSION = 'v18.0';
const META_API_BASE_URL = `https://graph.facebook.com/${META_API_VERSION}`;
const META_ACCESS_TOKEN = process.env.META_ACCESS_TOKEN;

/**
 * Retrieve interest suggestions from the Meta API
 * @param {string} query - Search text
 * @returns {Promise<Array>} - List of suggestions
 */
async function getSuggestions(query) {
  try {
    const url = `${META_API_BASE_URL}/search`;
    const params = {
      type: 'adinterest',
      q: query,
      limit: 10,
      access_token: META_ACCESS_TOKEN
    };

    const response = await axios.get(url, { params });
    return response.data?.data || [];
  } catch (error) {
    console.error('Error while retrieving Meta suggestions:', error.response?.data || error);
    return [];
  }
}

/**
 * Find the best match among Meta suggestions for a given criterion
 * @param {string} criterion - Original criterion
 * @param {string} context - Audience context for relevance evaluation
 * @returns {Object|null} - Best match or null if none found
 */
async function findBestMatch(criterion, suggestions, context) {
  if (!suggestions || suggestions.length === 0) {
    return null;
  }

  // Si une correspondance exacte existe, la retourner
  const exactMatch = suggestions.find(s => {
    return s.name.toLowerCase() === criterion.toLowerCase();
  });

  if (exactMatch) {
    return {
      original: criterion,
      matched: exactMatch.name,
      id: exactMatch.id,
      path: exactMatch.path || [],
      audience_size_lower_bound: exactMatch.audience_size_lower_bound,
      audience_size_upper_bound: exactMatch.audience_size_upper_bound
    };
  }

  // Sinon, essayer de trouver la meilleure correspondance contextuelle
  // En utilisant une heuristique simple pour l'instant
  const bestMatch = suggestions[0]; // For now, just take the first suggestion
  
  if (bestMatch) {
    return {
      original: criterion,
      matched: bestMatch.name,
      id: bestMatch.id,
      path: bestMatch.path || [],
      audience_size_lower_bound: bestMatch.audience_size_lower_bound,
      audience_size_upper_bound: bestMatch.audience_size_upper_bound
    };
  }

  return null;
}

// Simple similarity function (Jaccard + inclusion + context)
function computeSimilarity(a, b, context = '') {
  if (!a || !b) return 0;
  const aNorm = a.toLowerCase();
  const bNorm = b.toLowerCase();
  if (aNorm === bNorm) return 1;
  if (aNorm.includes(bNorm) || bNorm.includes(aNorm)) return 0.9;
  // Jaccard on words
  const aWords = new Set(aNorm.split(/\W+/));
  const bWords = new Set(bNorm.split(/\W+/));
  const intersection = new Set([...aWords].filter(x => bWords.has(x)));
  const union = new Set([...aWords, ...bWords]);
  let score = intersection.size / union.size;
  // Bonus if the context contains words from the criterion
  if (context && (context.toLowerCase().includes(aNorm) || context.toLowerCase().includes(bNorm))) {
    score += 0.1;
  }
  return Math.min(score, 0.95);
}

/**
 * Validate the criteria proposed by OpenAI with the Meta API
 * @param {Object} aiCriteria - Criteria structure generated by OpenAI
 * @returns {Promise<Object>} - Validated criteria structure
 */
async function validateCriteria(aiCriteria, options = {}) {
  const { retryOpenAI = false, maxRetries = 1, onSimilarityTiming } = options;
  try {
    if (!aiCriteria.themes || !Array.isArray(aiCriteria.themes)) {
      throw new Error("OpenAI response does not contain the expected structure (key 'themes').");
    }
    const validatedThemes = [];
    const context = aiCriteria.themes
      .map(theme => Object.entries(theme)
        .filter(([key]) => key !== 'name')
        .map(([, values]) => Array.isArray(values) ? values.join(', ') : '').join('; ')
      ).join('; ');
    for (const theme of aiCriteria.themes) {
      const validatedTheme = { name: theme.name };
      for (const [section, interests] of Object.entries(theme)) {
        if (section === 'name' || !Array.isArray(interests)) continue;
        const validatedInterests = [];
        for (const interest of interests) {
          const suggestions = await getSuggestions(interest);
          // Prendre les 3 meilleures suggestions Meta et scorer
          const scored = suggestions.slice(0, 3).map(s => ({
            ...s,
            score: computeSimilarity(interest, s.name, context),
            original: interest
          }));
          // Trier par score (et taille d'audience si égalité)
          scored.sort((a, b) => b.score - a.score || (b.audience_size_upper_bound || 0) - (a.audience_size_upper_bound || 0));
          let best = scored[0];
          // Si aucune suggestion n'est trouvée, fallback sur la logique d'alternatives
          let attempts = 0;
          while ((!best || best.score < 0.3) && retryOpenAI && attempts < maxRetries) {
            const simStart = Date.now();
            const alternatives = await openaiService.findAlternativeCriteria(interest, context);
            const simEnd = Date.now();
            if (typeof onSimilarityTiming === 'function') {
              onSimilarityTiming(simEnd - simStart);
            }
            for (const altObj of alternatives) {
              const alt = typeof altObj === 'string' ? altObj : altObj.alternative;
              const altSuggestions = await getSuggestions(alt);
              const altScored = altSuggestions.slice(0, 3).map(s => ({
                ...s,
                score: computeSimilarity(interest, s.name, context),
                original: interest
              }));
              altScored.sort((a, b) => b.score - a.score || (b.audience_size_upper_bound || 0) - (a.audience_size_upper_bound || 0));
              if (altScored[0] && (!best || altScored[0].score > best.score)) {
                best = altScored[0];
              }
            }
            attempts++;
          }
          if (best) {
            validatedInterests.push({
              original: best.original,
              matched: best.name,
              id: best.id,
              score: best.score,
              audience_size_lower_bound: best.audience_size_lower_bound,
              audience_size_upper_bound: best.audience_size_upper_bound
            });
          }
        }
        if (validatedInterests.length > 0) {
          validatedTheme[section] = validatedInterests;
        }
      }
      validatedThemes.push(validatedTheme);
    }
    return {
      themes: validatedThemes
    };
  } catch (error) {
    console.error('Error while validating criteria:', error);
    throw new Error('Error while validating audience criteria');
  }
}

module.exports = {
  getSuggestions,
  validateCriteria
};